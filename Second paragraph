----***Python数据结构***----



1.列表(list)    ---- 可变序列
1.1列表的创建和删除
#test
a_list=['wahaha','jim1',2,3,[4,5]]    
或者  b_list=list('hello world')   调用list函数
del a_list删除对象，如果无别的对象指向其则系统会自动删除值，回收内存空间

1.2元素增加和删除
+有一样的效果，但是是新建一个新的列表        //需要复制原来的元素，时间花销大
append，原地修改列表，在列表尾部加入元素     
extend(),加入另一个列表的所有元素
insert(a,b)，将元素插入到指定的位置a是位置，其中是从0开始的，后面是元素
*法可以用来列表全部自身的复制
del a_lisy[1]删除指定位置的元素
pop(a)指定下标的元素，默认最后一个元素
remove(a)删除首次出现的指定元素，不存在则抛出异常


1.3列表元素的访问和计数
a_list.index(value,[start,[stop]])
a_list.count[a]某个元素出现的次数
in --not in---在不在列表里面

1.4切片操作
a_list[a:b:c]  a是起始位置 b是截止位置 c是步长 但是其不会因为下标超出而报错而是简单返回一个空列表
//实质上，顾名思义，切片，将列表进行切片，然后在结合相应函数操作
可以实现列表的增，删，元素替换等
注意：切片是浅复制，就和两个对象指向相同一个列表值不同。实际是重新复制了一个列表值，在内存中重新分配对象。

1.5列表排序
a_list.sort()/sort(reverse=true)
sorted(a)/sorted(a,reverse=true)  //逆序排序，从大到小
a.reverse()是列表元素翻转
new_a=reversed(a) 对列表对象进行逆序排序，但是返回的是一个迭代对象，只能用一次
ps: sum() max() min() len() zip(a,b,c)一一对应再组成新的元组   enumerate()???枚举对象？？？

1.6列表推导式
结果是列表     //感觉是列表里面用了循环，符合Python的主旨，能一行写就不两行写









2.元组(tuple)   ------不可变的序列：格式-----（数据）（一旦初始化了就不能修改元素的值，除非创建新的元组）
2.1元组的创建和删除
a=(1，)  //一个元素需要在后面加个，
tuple() 可以讲别的类型转化为元组
del 整个元组，不存在个别元素的操作
支持切片访问元组中的数据，不能修改
tuple<----->list   相互转化的效果是，一个固定了一个可变了    ps:元组可做字典的键

2.2序列解包
eg：
s=(1,2,3,4)
a,b,c,d=s
print a,b,c,d
#序列解包       

2.3 生成器对象
类比于1.6的列表推导，只不过是用的（）
s=((i+3)**2 for i in range(10))
print tuple(s)   
#s就是生成器对象，其只能用一次，可以转化为list和tuple，也可以使用next()一个个遍历
#有点像java里面的iterator






3.字典   ------键值对！！的无序！！可变！！序列   ------键为任意不可变的数据，不能用列表集合字典做键，不允许重复键可以重复值
3.1字典的创建和删除
#直接建
a={1:'jim',2:'i','final':'to1'}

#用dict
keys=[1,2,3,4,'final']
values=['i','am','mvp',4,5]
s=dict(zip(keys,values))
print s

#直接键值对
d=dict('jim'=2,2=3)

3.2字典元素的读取
s[key]---读出其值--不存在则抛出异常
s.get(key)---不存在就none
s.items()

3.3字典元素的操作
s.update(q)  ----字典最大的特点就是键的唯一性，所以在update方法时如果有相同的键会覆盖原来的值


4.集合























 
